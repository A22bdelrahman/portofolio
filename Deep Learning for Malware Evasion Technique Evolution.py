import torch
import torch.nn as nn
import torch.optim as optim

# Similar to Project 3, but for 'malware' binaries as vectors
class Gen(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(5, 10)

    def forward(self, x):
        return torch.tanh(self.fc(x))

class Disc(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(10, 1)

    def forward(self, x):
        return torch.sigmoid(self.fc(x))

G = Gen()
D = Disc()
crit = nn.BCELoss()
g_opt = optim.SGD(G.parameters(), lr=0.01)
d_opt = optim.SGD(D.parameters(), lr=0.01)

real = torch.ones(16, 10)
noise = torch.randn(16, 5)

for _ in range(5):
    d_opt.zero_grad()
    fake = G(noise)
    d_r = D(real)
    d_f = D(fake.detach())
    d_loss = crit(d_r, torch.ones(16,1)) + crit(d_f, torch.zeros(16,1))
    d_loss.backward()
    d_opt.step()

    g_opt.zero_grad()
    d_f = D(fake)
    g_loss = crit(d_f, torch.ones(16,1))
    g_loss.backward()
    g_opt.step()

print(f"Evasion GAN trained with G loss {g_loss.item():.4f}, D loss {d_loss.item():.4f}")